---
layout: default
---

[/index](../bios.md)

#### Learn to write the same low-level code as we did with assembler, but in C

Compile
-------

Let's see how the C compiler compiles our code and compare it to the machine code
generated with the assembler.

Lets say we have a simple program which contains a function, `function.c`.

To compile system-independent code, we need the flag `-ffreestanding`, so compile
`function.c` in this fashion:

`i386-elf-gcc -ffreestanding -c function.c -o function.o`

Let's examine the machine code generated by the compiler:

`i386-elf-objdump -d function.o`


Link
----

To produce a binary file, we will use the linker. An important part of this
step is to learn how high level languages call function labels. Which is the offset
where our function will be placed in memory? We don't actually know. For this
example, we'll place the offset at `0x0` and use the `binary` format which
generates machine code without any labels and/or metadata

`i386-elf-ld -o function.bin -Ttext 0x0 --oformat binary function.o`

*Note: a warning may appear when linking, disregard it*

Now examine both "binary" files, `function.o` and `function.bin` using `xxd`. You
will see that the `.bin` file is machine code, while the `.o` file has a lot
of debugging information, labels, etc.


Decompile
---------

As a curiosity, we will examine the machine code.

`ndisasm -b 32 function.bin`

#### Create a simple kernel and a bootsector capable of booting it

The kernel
----------

Our C kernel will just print an 'X' on the top left corner of the screen. 

```c
/* This will force us to create a kernel entry function instead of jumping to kernel.c:0x00 */
void dummy_test_entrypoint() {
}

void main() {
    char* video_memory = (char*) 0xb8000;
    *video_memory = 'X';
}
```

`i386-elf-gcc -ffreestanding -c cfile -o ofile`

You will notice a dummy function that does nothing. That function will force us
to create a kernel entry routine which does not point to byte 0x0 in our kernel, but
to an actual label which we know that launches it. In our case, function `main()`.

That routine is coded on assembly. Read it and you will learn how to
use `[extern]` declarations in assembly. 
```nasm
[bits 32]
[extern main] ; Define calling point. Must have same name as kernel.c 'main' function
call main ; Calls the C function. The linker will know where it is placed in memory
jmp $
```
To compile this file, instead of generating
a binary, we will generate an `elf` format file which will be linked with `ofile`

`nasm asmfile -f elf -o ofile`

The linker
----------

A linker is a very powerful tool and we only started to benefit from it.

To link both object files into a single binary kernel and resolve label references,
run:

`i386-elf-ld -o binfile -Ttext 0x1000 ofiles --oformat binary`

Notice how our kernel will be placed not at `0x0` in memory, but at `0x1000`. The
bootsector will need to know this address too.


The bootsector
--------------

Compile bootsector from previous lessons with `nasm asmfile -f bin -o binfile`


Putting it all together
-----------------------

We have two separate files for the bootsector and the kernel. We'll "link" them together into a single file.

`cat bin1 bin2 > os-image.bin`


Run!
----

You can now run `os-image.bin` with qemu.

Remember that if you find disk load errors you may need to play with the disk numbers
or qemu parameters (floppy = `0x0`, hdd = `0x80`). I usually use `qemu-system-x86_64 -fda os-image.bin`

